<!doctype html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://distill.pub/template.v2.js"></script>
  <!-- <script src="http://localhost:8888/dist/template.v2.js"></script> -->
  <style>
    <%= require("./style.css") %>
  </style>
</head>

<body>

<d-front-matter>
  <script type="text/json">{
  "title": "Simple & Flexible Feature Visualization",
  "description": "Description of the post",
  "password": "clarity",
  "authors": [
    {
      "author":"Chris Olah",
      "authorURL":"https://colah.github.io/",
      "affiliation":"Google Brain",
      "affiliationURL":"https://g.co/brain"
    },
    {
      "author":"Alexander Mordvintsev",
      "authorURL":"https://znah.net/",
      "affiliation":"Google Brain",
      "affiliationURL":"https://g.co/brain"
    },
    {
      "author":"Ludwig Schubert",
      "authorURL":"https://schubert.io/",
      "affiliation":"Google Brain",
      "affiliationURL":"https://g.co/brain"
    }
  ]
  }</script>
</d-front-matter>


<d-title>
  <h1>Feature Visualization</h1>
  <!-- <p style="grid-column: text;">How neural networks build up their understanding of images</p> -->
  <figure class="base-grid" id="googlenet-examples"></figure>
</d-title>

<d-article>

<p>
  Neural network feature visualization is a powerful technique. It can answer questions about what a network -- or parts of a network -- are looking for by generating idealized examples of what the network is trying to find.
</p>
<p>
  Over the last few years, the field has made great strides in feature visualization. Actually getting it to work, however, involves a number of details. In this article, we examine the major issues and explore common approaches to solving them.
</p>
<p>
  We find that remarkably simple methods can produce state-of-the-art visualizations. Along the way we introduce a few tricks for exploring variation in what neurons react to, how they interact, and how to improve the optimization process.
</p>

<hr />
<!-- =================================================== -->
<h2 id="optimization">Feature Visualization by Optimization</h2>

<p>
  Neural networks are, generally speaking, differentiable with respect to their inputs.
  If we want to find out what kind of input would cause a certain behavior
  -- whether that’s an internal neuron firing or the final output behavior --
  we can use derivatives to iteratively tweak the input
  towards that goal <d-cite key="erhan2009visualizing"></d-cite>.
</p>

<figure class="base-grid" style="min-height: 168px;">
  <figcaption style="grid-column: kicker;">Starting from random noise, we optimize an image to activate a particular neuron (layer mixed4a, unit 11).</figcaption>
  <d-figure id="opt-progress" style="grid-column: text;"></d-figure>
</figure>

<p>
  While conceptually simple, there are subtle challenges in getting the optimization to work. We will explore them, as well as common approaches to tackle them in the section "<a href="#enemy-of-feature-vis">The Enemy of Feature Visualization</a>".
</p>

<h3 id="optimization-objectives">Optimization Objectives</h3>

<p>
  What do we want examples of?
  This is the core question in working with examples, regardless of whether we're searching through a dataset to find the examples, or optimizing images to create them from scratch.
</p>

<p>
  We have a wide variety of options in what we search for.
  If we want to understand individual features, we can search for examples where they have high values -- either at an individual neuron, or for an entire channel.
  If we want to understand a layer as a whole, we can use the DeepDream objective <d-cite key="mordvintsev2015inceptionism"></d-cite>, searching for images the layer finds "interesting."
  And if we want to create examples of output classes from a classifier, we have two options:
</p>

<figure class="base-grid" id="optimization-objectives">
  <style>
    #optimization-objectives .objectives {
      grid-column: text;
      grid-template-columns: repeat(1, 1fr);
    }
    
    #optimization-objectives .objective {
      display: grid;
      grid-template-columns: repeat(2, 1fr) 1.1fr;
    }
    
    #optimization-objectives .objectives figcaption {
      padding: 4px 8px;
      word-wrap: break-word;
      word-break: break-word;
    }
    
    #optimization-objectives .objective .objective-icon {
      padding: 8px;    
    }
    
    @media (min-width: 512px) {
      #optimization-objectives .objectives {
        grid-template-columns: repeat(5, 1fr);
        grid-column-gap: 16px;
      }
      
      #optimization-objectives .objective {
        display: flex;
        flex-flow: column;
      }
      
      #optimization-objectives .objectives figcaption {
        padding: 0;
        padding-top: 4px;
        word-wrap: break-word;
        word-break: break-word;
      }
    }
  </style>
  
  <figcaption style="grid-column: kicker;">
    <p>Different <strong>optimization objectives</strong> show what different parts of a network are looking for.</p>
    <br>
    <p><code><strong>n</strong></code> layer index <br />
      <code><strong>x,y</strong></code> spatial position<br />
      <code><strong>z</strong></code> channel index <br />
      <code><strong>k</strong></code> class index</p>
  </figcaption>
  
  <div class="objectives grid">
    <div class="objective">
      <div class="objective-icon">
        <img inline src="static/images/objectives/objectives_neuron.svg">
      </div>
      <img class="objective-opt" src="images/objectives/neuron.png">
      <figcaption><strong>Neuron</strong><br/><code>layer<sub>n</sub>[x,y,z]</code></figcaption>
    </div>
    
    <div class="objective">
      <div class="objective-icon">
        <img inline src="static/images/objectives/objectives_channel.svg">
      </div>
      <img class="objective-opt" src="images/objectives/channel.png">
      <figcaption><strong>Channel</strong><br/><code>layer<sub>n</sub>[:,:,z]</code></figcaption>
    </div>
    
    <div class="objective">
      <div class="objective-icon">
        <img inline src="static/images/objectives/objectives_layer.svg">
      </div>
      <img class="objective-opt" src="images/objectives/layer.png">
      <figcaption><strong>Layer</strong>/DeepDream<br/><code>layer<sub>n</sub>[:,:,:]<sup>2</sup></code></figcaption>
    </div>
    
    <div class="objective">
      <div class="objective-icon">
        <img inline src="static/images/objectives/objectives_logits_pre.svg">
      </div>
      <img class="objective-opt" src="images/objectives/logits.png">
      <figcaption><strong>Class Logits</strong><br/><code>pre_softmax[k]</code></figcaption>
    </div>
    
    <div class="objective">
      <div class="objective-icon">
        <img inline src="static/images/objectives/objectives_logits_post.svg">
      </div>
      <img class="objective-opt" src="images/objectives/logits_post.png">
      <figcaption><strong>Class Probability</strong><br/><code>softmax[k]</code></figcaption>
    </div>
  </div>
</figure>

<p>
  These two different objectives for output classes are a very important distinction between the pre-softmax logit objective and the post-softmax probabilities objective.
  One can see the logits as the evidence for each class, and the probabilities as the likelihood of each class given the evidence.
  Unfortunately, the easiest way to increase the probability softmax gives to a class is often to make the alternatives unlikely rather than to make the class of interest likely <d-cite key="simonyan2013deep"></d-cite>.
  This can be fixed by very strong regularization with generative models, in which case the probabilities can be a very principled thing to optimize.
  From our experience, optimizing pre-softmax logits produces images of better visual quality.<d-footnote>
    While the standard explanation is that maximizing probability doesn't work very well because you can just push down evidence for other classes, an alternate hypothesis is that it's just harder to optimize through the softmax function. We understand this has sometimes been an issue in adversarial examples, and the solution is to optimize the LogSumExp of the logits instead. This is equivalent to optimizing softmax but generally more tractable. Our experience was that the LogSumExp trick doesn't seem better than dealing with the raw probabilities.
  </d-footnote>
</p>

<p>
  The objectives we've mentioned barely scratch the surface of the possibilities
  -- it would be impossible to list all the things people have tried.
  Of particular note are the objectives used in style transfer <d-cite key="gatys2015neural"></d-cite>, which can teach us about the kinds of style and content a network understands,
  and objectives used in optimization-based model inversion <d-cite key="mahendran2015understanding"></d-cite>, which help us understand what information a model keeps and what it throws away.
</p>

<h3 id="why-optimization">Why visualize by optimization?</h3>

<p>
  Optimization can give us an example input that causes the desired behavior
  -- but why bother with that?
  Couldn't we just look through the dataset for examples that cause the desired behavior?
</p>

<p>
  It turns out that optimization approach can be a powerful way to understand what a model is really looking for,
  because it separates the things causing behavior from from things that merely correlate with the causes.
  For example, consider the following neurons visualized with dataset examples and optimization:
</p>

<figure style="grid-column: screen;">
  <d-figure class="base-grid" id="example-optimization-comparison"></d-figure>
</figure>

<p>
  Optimization also has the advantage of flexibility.
  For example, if we want to study how neurons jointly represent information,
  we can easily ask how a particular example would need to be different for an additional neuron to activate.
  This flexibility can also be helpful in visualizing how features evolve as the network trains.
  If we were limited to understanding the model on the fixed examples in our dataset, topics like these ones would be much harder to explore.
</p>

<p>
  On the other hand, there are also significant challenges to visualizing features with optimization.
  In the following sections we'll examine techniques to get diverse visualizations, understand how neurons interact, and avoid high frequency artefacts.
</p>


<!-- =================================================== -->
<hr/>
<h2 id="diversity">Diversity</h2>

<!-- TODO: improve las sentence -->
<p>
  Do our examples show us the full picture? 
  When we create examples by optimization, this is something we need to be very careful of.
  It's entirely possible for genuine examples to still mislead us by only showing us one facet of what a feature represents.
</p>

<p>
  Dataset examples have a big advantage here.
  By looking through our dataset, we can find diverse examples.
  It doesn't just give us ones activating a neuron intensely:
  we can look across a whole spectrum of activations to see what activates the neuron to different extents.
</p>

<!-- <figure class="l-page-outset"><img src="images/vis_ActivationSpectrum.svg" style="min-height: 150px;"></img></figure> -->


<figure style="grid-column: screen;" class="shaded-figure">
  <d-figure class="base-grid" id="optimization-and-examples"></d-figure>
</figure>


<!-- <figure class="l-page-outset row" id="tmptest">
  <img class="column" src="https://cnsviewer2.corp.google.com/cns/in-d/home/ludwigschubert/visualize_channels/diagrams/mixed4a-00492/0-min.jpg">
  <img class="column" src="https://cnsviewer2.corp.google.com/cns/in-d/home/ludwigschubert/visualize_channels/diagrams/mixed4a-00492/1-some_negative.jpg">
  <img class="column" src="https://cnsviewer2.corp.google.com/cns/in-d/home/ludwigschubert/visualize_channels/diagrams/mixed4a-00492/2-zero.jpg">
  <img class="column" src="https://cnsviewer2.corp.google.com/cns/in-d/home/ludwigschubert/visualize_channels/diagrams/mixed4a-00492/3-some_positive.jpg">
  <img class="column" src="https://cnsviewer2.corp.google.com/cns/in-d/home/ludwigschubert/visualize_channels/diagrams/mixed4a-00492/4-max.jpg">
</figure> -->
<p>
  In contrast, optimization generally gives us just one extremely positive example -- and if we're creative, a very negative example as well. 
  Is there some way that optimization could also give us this diversity?
</p>

<h3 id="diversity-with-optimization">Achieving Diversity with Optimization</h3>

<p>
  As is often the case in visualizing neural networks, this problem was initially recognized and addressed by Nguyen, Yosinski, and collaborators.
  Their initial approach was to search through the dataset for diverse examples and use those as starting points for the optimization process <d-cite key="nguyen2016multifaceted"></d-cite>.
  The idea is that this initiates optimization in different facets of the feature so that the resulting example from optimization will demonstrate that facet.
  In more recent work, they combine visualizing classes with a generative model, which they can sample for diverse examples <d-cite key="nguyen2016plug"></d-cite>.
</p>

<p>
  The first approach had limited success, and while the generative model approach works very well -- we'll discuss it in more depth later -- it can be a bit tricky. 
</p>

<p>
  We find there's a very simple way to achieve diversity: adding a "diversity term" to one's objective that pushes multiple examples to be different from each other.
  The diversity term can take a variety of forms, and we don't have much understanding of their benefits yet.
  One possibility is to penalize the cosine similarity of different examples.
  Another is to use ideas from style transfer <d-cite key="gatys2015neural"></d-cite> to force the feature to be displayed in different styles.
  <d-footnote>
    For this article we use an approach based on ideas from artistic style transfer. Following that work, we begin by computing the Gram matrix of the channels.
    <d-math block>
      G_{i,j} = \text{layer}_n\text{[:, :, i]} \cdot \text{layer}_n\text{[:, :, j]}
    </d-math>
    From this, we compute the pairwise cosine similarity of pairs of visualizations:
    <d-math block>
      C_{\text{diversity}} = - \sum_{a} \sum_{b\neq a} ~ \frac{G_a \cdot G_b}{||G_a||~||G_b||} 
    </d-math>
  </d-footnote>
</p>

<p>
  In lower level neurons, a diversity term can reveal the different facets a feature represents:
</p>

<figure class="grid l-page" style="grid-template-columns: repeat(6, 1fr)">
  <div style="">
    <img style="max-width: 147px;" src="images/diversity/mixed4a_97_optimized.png" />
    <figcaption>Optimization</figcaption>
  </div>
  <div style="grid-column-end: span 4">
    <img src="images/diversity/mixed4a_97_diversity.png" />
    <figcaption>
      Four different, curvy facets. <i>Layer mixed4a, Unit 97</i>
    </figcaption>
  </div>
  <div style="">
    <img style="max-width: 147px;"src="images/diversity/mixed4a_97_examples.jpg" />
    <figcaption>Dataset examples</figcaption>
  </div>
</figure>


<p>
  Diverse feature visualizations allow us to more closely pinpoint what activates a neuron, to the degree that we can make, and -- by looking at dataset examples -- <em>check</em> predictions about what inputs will activate the neuron.
</p>

<figure class="grid l-page" style="grid-template-columns: repeat(6, 1fr)">
  <div style="">
    <img style="max-width: 147px;" src="images/diversity/mixed4a_143_optimized.png" />
    <figcaption>Optimization</figcaption>
  </div>
  <div style="grid-column-end: span 4">
    <img src="images/diversity/mixed4a_143_diversity.png" />
    <figcaption>
      Optimization with diversity shows different facets of the feature. <i>Layer mixed4a, Unit 143</i>
    </figcaption>
  </div>
  <div style="">
    <img style="max-width: 147px;"src="images/diversity/mixed4a_143_examples.jpg" />
    <figcaption>Dataset examples</figcaption>
  </div>
</figure>

<p>
  The effect of diversity can be even more striking in higher level neurons, where it can show us different types of objects that stimulate a neuron.
  For example, one neuron seems to responds to people's shoulders and arms.
</p>

<figure class="grid l-page" style="grid-template-columns: repeat(6, 1fr)">
  <div style="">
    <img style="max-width: 147px;" src="images/diversity/mixed4e_718_optimized.png" />
    <figcaption>Optimization</figcaption>
  </div>
  <div style="grid-column-end: span 4">
    <img src="images/diversity/mixed4e_718_diversity.png" />
    <figcaption>Shoulders & arms? <i>Layer mixed4e, Unit 718</i></figcaption>
  </div>
  <div style="">
    <img style="max-width: 147px;"src="images/diversity/mixed4e_718_examples.jpg" />
    <figcaption>Dataset examples</figcaption>
  </div>
</figure>

<p>
  This neuron responds to different kinds of balls, even though they have a variety of appearances.
</p>

<figure class="grid l-page" style="grid-template-columns: repeat(6, 1fr)">
  <div style="">
    <img style="max-width: 147px;" src="images/diversity/mixed5a_9_optimized.png" />
    <figcaption>Optimization</figcaption>
  </div>
  <div style="grid-column-end: span 4">
    <img src="images/diversity/mixed5a_9_diversity.png" />
    <figcaption>Multiple types of balls? <i>Layer mixed5a, Unit 9</i></figcaption>
  </div>
  <div style="">
    <img style="max-width: 147px;"src="images/diversity/mixed5a_9_examples.jpg" />
    <figcaption>Dataset examples</figcaption>
  </div>
</figure>

<p>
  While the examples above represent a mostly coherent idea, there are also neurons that represent strange mixtures of ideas.
  Below, a neuron to responds to two types of animal faces, and also to car bodys.
</p>

<figure class="grid l-page" style="grid-template-columns: repeat(6, 1fr)">
  <div style="">
    <img style="max-width: 147px;" src="images/diversity/mixed4e_55_optimized.png" />
    <figcaption>Optimization</figcaption>
  </div>
  <div style="grid-column-end: span 4">
    <img src="images/diversity/mixed4e_55_diversity.png" />
    <figcaption>Cats, foxes and cars? <i>Layer mixed4e, Unit 55</i></figcaption>
  </div>
  <div style="">
    <img style="max-width: 147px;"src="images/diversity/mixed4e_55_examples.jpg" />
    <figcaption>Dataset examples</figcaption>
  </div>
</figure>

<p>
  Examples like these suggest that neurons are not necessarily the right semantic units for understanding neural nets.
</p>

<!-- =================================================== -->
<hr/>
<h2 id="interaction">Interaction between Neurons</h2>

<p>
  If neurons are not the right way to understand neural nets, what is?
  In real life, combinations of neurons work together to represent images in neural networks. 
  Individual neurons are the basis directions of activation space, and it is not clear that these should be any more special than any other direction.
</p>

<p>
  <d-cite key="szegedy2013intriguing">Szegedy <i>et al.</i></d-cite> found that random directions seem just as meaningful as the basis directions.
  More recently <d-cite key="netdissect2017">Bau, Zhou <i>et al.</i></d-cite> found basis directions to be interpretable more often than random directions.
  Our experience is broadly consistent with both results; we find that random directions often seem interpretable, but at a lower rate than basis directions.
</p>

<figure class="base-grid" >
  <figcaption style="grid-column: kicker;">
    Dataset examples and optimized examples of <strong>random directions</strong> in activation space. The directions shown here were hand-picked for interpretability.
  </figcaption>
  <d-figure style="grid-column: text-start / page-end;" id="random-optimization-and-examples"></d-figure>
</figure>

<p>  
  We can also define interesting directions in activation space by doing arithmetic on neurons.
  For example, if we add a "black and white" neuron to a "mosaic" neuron, we obtain a black and white version of the mosaic.
  This is reminiscent of semantic arithmetic of word embeddings as seen in Word2Vec or generative models' latent spaces.
</p>

<figure class="base-grid shaded-figure">
  <figcaption style="grid-column: kicker;">
    By jointly optimizing two neurons we can get a sense of how they interact.
  </figcaption>
  <d-figure style="grid-column: text; overflow: visible;" id="linear-combinations"></d-figure>
</figure>

<p>
  These examples show us how neurons jointly represent images.
  To better understand how neurons interact, we can also interpolate between them. 
  <d-footnote>The optimization objective is a linear interpolation between the individual channel objectives. To get the interpolations to look better, we also add a small alignment objective that encourages lower layer activations to be similar. We additionally use a combination of separate and shared image parameterizations to make it easier for the optimization algorithm to cause objects to line up, while still giving it the freedom to create any image it needs to.</d-footnote>
  This is similar to interpolating in the latent space of generative models. 
</p>

<figure class="base-grid shaded-figure">
  <d-figure style="grid-column: text-start / page-end;" id="interpolation"></d-figure>
</figure>

<p>
  This is only starting to scratch the surface of how neurons interact. 
  The truth is that we have almost no clue how to select meaningful directions, or whether there even exist particularly meaningful directions.
  Independant of finding directions, there are also questions on how directions interact--for example, interpolation can show us how a small number of directions interact, but in reality there are hundreds of directions interacting.
</p>


<!-- =================================================== -->
<hr/>
<h2 id="enemy-of-feature-vis">The Enemy of Feature Visualization</h2>


<h3 id="high-frequency">High Frequency Patterns</h3>  

<p>
  If you want to visualize features, you might just optimize an image to make neurons fire.
  Unfortunately, this doesn't really work.
  Instead, you end up with a kind of neural network optical illusion
  -- an image full of noise and nonsensical high-frequency patterns that the network responds strongly to.
</p>

<figure class="shaded-figure base-grid">
  <figcaption style="grid-column: kicker;">
    <p>Even if you carefully tune learning rate, you'll get noise.</p><br />
    <p>In this and the following figures the optimization result is enlarged to show detail.</p>
  </figcaption>
  <d-figure style="grid-column: text;" id="optimize-naive"></d-figure>
</figure>

<!-- TODO: Add caption encouraging user to fiddle with learning rate -->

<p>
  These patterns seem to be the images kind of cheating, finding ways to activate neurons that don't occur in real life.
  If you optimize long enough, you'll tend to see some of what the neuron genuinely detects as well,
  but the image is dominated by these high frequency patterns.
  These patterns seem to be closely related to the phenomenon of adversarial examples <d-cite key="szegedy2013intriguing"></d-cite>.
</p>

<p>
  We don't fully understand why these high frequency patterns form,
  but an important part seems to be strided convolutions and pooling operations, which create high-frequency patterns in the gradient <d-cite key="odena2016deconvolution"></d-cite>.
</p>

<figcaption>Each <b>strided convolution</b> creates checkerboard patterns in the gradient magnitudes when we backprop through it. <dt-cite key="odena2016deconvolution"></dt-cite></figcaption>
<figure style="grid-column: page;">
  <d-figure id="frequency-artifacts"></d-figure>
</figure>


<p>
  These high-frequency patterns show us that, while optimization based visualization's freedom from constraints is appealing, it's a double-edged sword.
  Without any constraints on images, we end up with adversarial examples.
  These are certainly interesting, but if we want to understand how these models work in real life, we need to somehow move past them...
</p>

<h3 id="regularization">The Spectrum of Regularization</h3>

<p>
  Dealing with these high frequency noise has been one of the primary challenges and overarching threads of feature visualization research.
  If you want to get useful visualizations, you need to impose a more natural structure using some kind of prior, regularizer, or constraint.
</p>

<p>
  In fact, if you look at most notable papers on feature visualization, some approach to regularization will be one of their main points.
  Researchers have tried a lot of different things!
</p>

<p>
  We can think of all of these approaches as living on a spectrum, based on how strongly they regularize the model.
  On one extreme, if we don't regularize at all, we end up with adversarial examples.
  On the opposite end, we search over examples in our dataset and run into all the limitations we discussed earlier.
  And in the middle we have three main families of regularization options.
</p>

<figure style="grid-column: page; min-height: 750px; padding-bottom: 10px;">
  <d-figure id="feature-vis-history"></d-figure>
</figure>


<h3 id="regularization-families">Three Families of Regularization</h3>

<p>
  Let's consider these three intermediate categories of regularization in more depth.
</p>

<p>
  <b>Frequency penalization</b> directly targets the high frequency noise these methods suffer from.
  It may explicitly penalize variance between neighboring pixels (total variation) <d-cite key="mahendran2015understanding"></d-cite>, or implicitly penalize high-frequency noise by blurring the image each optimization step <d-cite key="nguyen2015deep"></d-cite>.<d-footnote>
    If we think about blurring in Fourier space, it is equivalent to adding a scaled L2 penalty to the objective, penalizing each Fourier-component based on its frequency.</d-footnote>
  Unfortunately, these approaches also discourage legitimate high-frequency features like edges along with noise.
  This can be slightly improved by using a bilateral filter, which preserves edges, instead of blurring <d-cite key="tyka2016bilateral"></d-cite>.
</p>

<p>
  (Some work uses similar techniques to reduce high frequencies in the gradient before they accumulate in the visualization <d-cite key="oygard2015vis,mordvintsev2016deepdreaming"></d-cite>.
  These techniques are in some ways very similar to the above and in some ways radically different -- we'll talk about them in much more depth later.)
</p>

<figure class="shaded-figure base-grid">
  <d-figure style="grid-column: text;" id="regularizer-playground-freq"></d-figure>
</figure>
<!--
  - none
  - Total variance
  - Blur
-->


<p>
  <b>Transformation robustness</b> tries to find examples that still work if we slightly transform them.
  Even a small amount seems to be very effective in the case of images <d-cite key="mordvintsev2015inceptionism"></d-cite>, 
  especially when combined with a more general regularizer for high-frequencies <d-cite key="oygard2015vis,mordvintsev2016deepdreaming"></d-cite>.
  This usually means that we "jitter" the image, applying the model at slight random offsets every optimization step,
  but other kinds of transformations also help.
</p>


<!--<figure id="optimize-jitter" class="l-page-outset"></figure>-->

<figure class="shaded-figure base-grid">
  <d-figure style="grid-column: text;" id="regularizer-playground-robust"></d-figure>
</figure>

<!--TODO(colah): Make a diagram of unconstraint opt vs paramaterized opt vs prior? Discuss using an inverse model?-->

<!-- technically most challenging -->

<p>
  <b>Learned priors.</b>
  Our previous regularizers use very simple heuristics to keep examples reasonable.
  A natural next step is to actually learn a model of the real data and try to enforce that.
  With a strong model, this becomes similar to searching over the dataset.
  This approach produces the most photorealistic visualizations, but it may be unclear what came from the model being visualized and what came from the prior.
</p>

<p>
  One approach is to learn a generator that maps points in a latent space to examples of your data,
  such as a GAN or VAE,
  and optimize within that latent space <d-cite key="nguyen2016synthesizing"></d-cite>. 
  An alternative approach is to learn a prior that gives you access to the gradient of probability;
  this allows you to jointly optimize for the prior along with your objective <d-cite key="nguyen2016plug,mordvintsev2015inceptionism"></d-cite>.
  When one optimizes for the prior and the probability of a class, one recovers a generative model of the data conditioned on that particular class.
</p>



<!-- =================================================== -->
<hr/>
<h2 id="preconditioning">Preconditioning and Parameterization</h2>

<br>

<p>
  In the previous section, we saw a few methods <d-cite key="oygard2015vis,mordvintsev2016deepdreaming"></d-cite> that reduced high frequencies <i>in the gradient</i> rather than the visualization itself.
  It's not clear this is really a regularizer:
  it resists high frequencies, but still allows them to form when the gradient consistently pushes for it.
</p>

<p>
  Transforming the gradient like this is a powerful tool.
  Optimizers call it preconditioning.
  You can think of it as doing steepest descent to optimize the same objective, 
  but in another parameterization of the space or under a different notion of distance.<d-footnote>
    Gradient blurring<d-cite key="oygard2015vis"></d-cite> is equivalent to gradient descent in a different paramaterization of image space, where high frequency dimensions are stretched to make moving in those directions slower. Gradient Laplacian Pyramid normalization <d-cite key="mordvintsev2016deepdreaming"></d-cite> is some kind of adaptive learning rate approach in the same space.
  </d-footnote>
  It changes how fast you move in each direction, but doesn't change what the minimums are.
  Using the right preconditioner can make an optimization problem radically easier.
  And if there are many local minima, it can stretch and shrink their basins of attraction, changing which ones you fall into.
</p>
<p>
  Of course, there are infinitely many possible preconditioners.
  How should we chose a good one that will give us these benefits?
  A good first guess is one that makes your data decorrelated and whitened.<d-footnote>
    In the case of images, this means doing gradient descent in the Fourier transform,
    with frequencies scaled so that they all have equal energy. This decorrelates images spatially, but doesn't handle correlations between colors. 
    To address this, we explicitly measure the correlation between colors in the training set and use a Cholesky decomposition to decorrelate them.</d-footnote>
  Let's compare the direction of steepest descent in a decorelated parameterization to two other directions of steepest descent:
</p>

<figure class="shaded-figure base-grid">
  <figcaption style="grid-column: kicker">
    Three directions of steepest descent under different notions of distance
  </figcaption>
  <d-figure style="grid-column: text-start / screen-end;" id="steepest-descent"></d-figure>
</figure>

<p>
  All of these directions are valid descent directions for the same objective,
  but we can see they're radically different.
  Notice that optimizing in the decorrelated space reduces high frequencies,
  while using L<sup>∞</sup> increases them. 
</p>

<p>
  Using the decorrelated descent direction results in quite different visualizations.
  It's hard to do really fair comparisons because of hyperparameters, but the
  resulting visualizations seem a lot better -- and develop faster, too.
</p>

<!-- Figure out which descent directions to have in playground, explain them in the text. -->
<figure class="shaded-figure base-grid">
  <d-figure style="grid-column: text;" id="opt-explore2"></d-figure>
</figure>

<p>
  Is the preconditioner merely accelerating descent, bringing us to the same place
  normal gradient descent would have brought us if we were patient enough?
  Or is it also regularizing, changing which local minima we get attracted to?
  It's hard to tell for sure.
  On the one hand, gradient descent seems to continue improving as you exponentially increase the number of optimization steps -- it hasn't converged, it's just moving very slowly.
  On the other hand, if you turn off all other regularizers, the preconditioner seems to reduce high-frequency patterns.
</p>

<!-- =================================================== -->
<hr/>
<h2 id="conclusion">Conclusion</h2>
  
<p class="">
  Neural feature visualization has made great progress over the last few years.
  As a community, we've developed principled ways to create compelling visualizations. 
  We've mapped out a number of important challenges and found ways of a addressing them.
</p>

<p class="">
  In the quest to make neural networks interpretable, feature visualization
  stands out as one of the most promising and developed research directions.
  By itself, feature visualization will never give a completely satisfactory
  understanding. We see it as one of the fundamental building blocks that,
  combined with additional tools, will empower humans to understand these systems.
</p>

</d-article>

<d-appendix>
  <h3 id="acknowledgements">Acknowledgments</h3>
  <p>
    We are extremely grateful to Shan Carter for thoughtful feedback -- especially design advice.
  </p>
  
  <p>
    We're also grateful for the comments, thoughts and support of
    Greg Corrado, Blaise Aguera y Arcas,
    Katherine Ye, Michael Nielsen, Emma Pierson, Dario Amodei, Ian Goodfellow,
    Mike Tyka,
    Andrea Vedaldi, Ruth Fong, 
    Timon Ruban,
    Been Kim, Martin Wattenberg, and Fernanda Viegas.
  </p>

  <h3 id="author-contributions">Author Contributions</h3>
  <p>
    The biggest technical contribution of this work is likely the section on preconditioning.
    Alex discovered in prior work that normalizing gradient frequencies had a radical effect on visualizing neurons.
    Chris reframed this as adaptive gradient descent in a different basis.
    Together, they iterated on a number of ways of paramaterizing images.
    Similarly, Alex originally introduced the use of diversity term, and Chris refined using it.
    Chris did the exploration of interpolating between neurons.
    All experiments were based on code written by Alex.
  </p>
  <p>
    We see another important part of this work as its expository value.
    Chris did most of the distillation of prior work and made most of the interactive diagrams.
    Ludwig created the visualization of the spectrum of neuron activations.
  </p>
  <d-footnote-list></d-footnote-list>
  <d-citation-list></d-citation-list>
</d-appendix>

<d-bibliography src="bibliography.bib"></d-bibliography>

</body>